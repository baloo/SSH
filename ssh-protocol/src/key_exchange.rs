//! Key Exchange support
//!
//! See <https://www.rfc-editor.org/rfc/rfc4253#section-7>

use std::io;

use digest::{Digest, Output, Update};
use encoding::{
    self, CheckedSum, Decode, DigestWriter, Encode, Error as EncodingError, Reader, Writer,
};
use rand_core::CryptoRngCore;

#[cfg(feature = "async")]
use {
    futures::{sink::SinkExt, stream::StreamExt},
    tokio::io::{AsyncRead, AsyncWrite},
    tokio_util::codec::Framed,
};

use crate::{codec::Codec, constants, read_command_code, ClientServer, Cookie, Error, NameList};

/// SSH2_MSG_KEXINIT
/// https://www.rfc-editor.org/rfc/rfc4253#section-7.1
#[derive(Clone, Debug, PartialEq)]
pub struct KeyExchangeInit {
    /// cookie
    ///   The 'cookie' MUST be a random value generated by the sender.
    ///   Its purpose is to make it impossible for either side to fully
    ///   determine the keys and the session identifier.
    pub cookie: Cookie,
    /// kex_algorithms
    pub kex_algorithms: NameList,
    /// server_host_key_algorithms
    ///   A name-list of the algorithms supported for the server host
    ///   key.  The server lists the algorithms for which it has host
    ///   keys; the client lists the algorithms that it is willing to
    ///   accept.  There MAY be multiple host keys for a host, possibly
    ///   with different algorithms.
    pub server_host_key_algorithms: NameList,
    /// encryption_algorithms
    ///   A name-list of acceptable symmetric encryption algorithms (also
    ///   known as ciphers) in order of preference.  The chosen
    ///   encryption algorithm to each direction MUST be the first
    ///   algorithm on the client's name-list that is also on the
    ///   server's name-list.  If there is no such algorithm, both sides
    ///   MUST disconnect.
    pub encryption_algorithms: ClientServer<NameList>,
    /// mac_algorithms
    ///   A name-list of acceptable MAC algorithms in order of
    ///   preference.  The chosen MAC algorithm MUST be the first
    ///   algorithm on the client's name-list that is also on the
    ///   server's name-list.  If there is no such algorithm, both sides
    ///   MUST disconnect.
    pub mac_algorithms: ClientServer<NameList>,
    /// compression_algorithms
    ///   A name-list of acceptable compression algorithms in order of
    ///   preference.  The chosen compression algorithm MUST be the first
    ///   algorithm on the client's name-list that is also on the
    ///   server's name-list.  If there is no such algorithm, both sides
    ///   MUST disconnect.
    pub compression_algorithms: ClientServer<NameList>,
    /// languages
    ///   This is a name-list of language tags in order of preference
    ///   [RFC3066].
    pub languages: ClientServer<NameList>,
    /// first_kex_packet_follows
    ///   Indicates whether a guessed key exchange packet follows.  If a
    ///   guessed packet will be sent, this MUST be TRUE.  If no guessed
    ///   packet will be sent, this MUST be FALSE.
    pub first_kex_packet_follows: bool,
}

impl Encode for KeyExchangeInit {
    fn encoded_len(&self) -> Result<usize, EncodingError> {
        [
            1, // command code
            self.cookie.encoded_len()?,
            self.kex_algorithms.encoded_len()?,
            self.server_host_key_algorithms.encoded_len()?,
            self.encryption_algorithms.encoded_len()?,
            self.mac_algorithms.encoded_len()?,
            self.compression_algorithms.encoded_len()?,
            self.languages.encoded_len()?,
            1, // first_kex_packet_follows
            4, // reserved
        ]
        .checked_sum()
    }

    fn encode(&self, writer: &mut impl Writer) -> Result<(), EncodingError> {
        constants::SSH_MSG_KEXINIT.encode(writer)?;

        self.cookie.encode(writer)?;
        self.kex_algorithms.encode(writer)?;
        self.server_host_key_algorithms.encode(writer)?;
        self.encryption_algorithms.encode(writer)?;
        self.mac_algorithms.encode(writer)?;
        self.compression_algorithms.encode(writer)?;
        self.languages.encode(writer)?;
        false.encode(writer)?;
        0u32.encode(writer)?;
        Ok(())
    }
}

impl Decode for KeyExchangeInit {
    type Error = Error;

    fn decode(reader: &mut impl Reader) -> Result<Self, Self::Error> {
        read_command_code(constants::SSH_MSG_KEXINIT, reader)?;

        let cookie = Cookie::decode(reader)?;

        let kex_algorithms = NameList::decode(reader)?;
        let server_host_key_algorithms = NameList::decode(reader)?;
        let encryption_algorithms = ClientServer::decode(reader)?;
        let mac_algorithms = ClientServer::decode(reader)?;
        let compression_algorithms = ClientServer::decode(reader)?;
        let languages = ClientServer::decode(reader)?;
        let first_kex_packet_follows = bool::decode(reader)?;

        Ok(Self {
            cookie,
            kex_algorithms,
            server_host_key_algorithms,
            encryption_algorithms,
            mac_algorithms,
            compression_algorithms,
            languages,
            first_kex_packet_follows,
        })
    }
}

impl KeyExchangeInit {
    /// Creates a new [`KeyExchangeInit`] from provided parameters
    pub fn new<Rng>(
        rng: &mut Rng,
        kex_algorithms: NameList,
        server_host_key_algorithms: NameList,
        encryption_algorithms: ClientServer<NameList>,
        mac_algorithms: ClientServer<NameList>,
        compression_algorithms: ClientServer<NameList>,
    ) -> Self
    where
        Rng: CryptoRngCore,
    {
        let cookie = Cookie::new(rng);
        Self {
            cookie,
            kex_algorithms,
            server_host_key_algorithms,
            encryption_algorithms,
            mac_algorithms,
            compression_algorithms,
            languages: Default::default(),
            first_kex_packet_follows: false,
        }
    }

    /// Send our half of the Key Exchange and return the peer's half.
    #[cfg(feature = "async")]
    pub async fn exchange<S>(&self, stream: &mut S) -> Result<Self, Error>
    where
        S: AsyncRead + AsyncWrite + Unpin,
    {
        let codec = Codec::<Self, Self>::default();
        let mut stream = Framed::new(stream, codec);

        // NOTE: this blocks until flushed, get that in tokio::join
        stream.send(self.clone()).await.map_err(|_e| {
            io::Error::new(
                io::ErrorKind::UnexpectedEof,
                "client disconnected before saying hello, how rude",
            )
        })?;

        let Some(msg) = stream.next().await else {
            return Err(io::Error::new(
                io::ErrorKind::UnexpectedEof,
                "client disconnected before saying hello, how rude",
            )
            .into());
        };

        msg
    }
}

/// Output of the key exchange
#[derive(Debug)]
pub struct SessionKeys<D>
where
    D: Digest,
{
    /// Pair of initialization vector
    pub initial_iv: ClientServer<Output<D>>,
    /// Pair of encryption keys
    pub encryption_key: ClientServer<Output<D>>,
    /// Pair of authentication keys
    pub integrity_key: ClientServer<Output<D>>,
}

impl<D> SessionKeys<D>
where
    D: Digest,
{
    /// Derive session keys from shared secret
    ///
    /// See: <https://www.rfc-editor.org/rfc/rfc4253#section-7.2>
    pub fn derive(shared_secret: &[u8], exchange_hash: &D, session_id: &D) -> Result<Self, Error>
    where
        D: Clone + Update,
    {
        let mut base_digest = D::new();
        shared_secret.encode(&mut DigestWriter(&mut base_digest))?;

        let base_digest = base_digest.chain_update(exchange_hash.clone().finalize());

        let initial_iv = ClientServer {
            client_to_server: base_digest
                .clone()
                .chain_update(&[b'A'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
            server_to_client: base_digest
                .clone()
                .chain_update(&[b'B'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
        };

        let encryption_key = ClientServer {
            client_to_server: base_digest
                .clone()
                .chain_update(&[b'C'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
            server_to_client: base_digest
                .clone()
                .chain_update(&[b'D'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
        };

        let integrity_key = ClientServer {
            client_to_server: base_digest
                .clone()
                .chain_update(&[b'E'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
            server_to_client: base_digest
                .clone()
                .chain_update(&[b'F'])
                .chain_update(session_id.clone().finalize())
                .finalize(),
        };

        Ok(SessionKeys {
            initial_iv,
            encryption_key,
            integrity_key,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use hex_literal::hex;
    use pretty_hex::PrettyHex;

    #[test]
    fn test_serialize() {
        let kex_algorithms = vec!["ecdh-sha2-nistp256".to_string()].into();
        let server_host_key_algorithms = vec!["ecdsa-sha2-nistp256".to_string()].into();
        let encryption_algorithms =
            ClientServer::new(vec!["chacha20-poly1305@openssh.com".to_string()].into());
        let mac_algorithms = ClientServer::default();
        let compression_algorithms = ClientServer::new(vec!["none".to_string()].into());
        let kex = KeyExchangeInit {
            cookie: Cookie::from([
                0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01,
                0x02, 0x03,
            ]),
            kex_algorithms,
            server_host_key_algorithms,
            encryption_algorithms,
            mac_algorithms,
            compression_algorithms,
            languages: Default::default(),
            first_kex_packet_follows: false,
        };

        let mut buf = Vec::new();
        kex.encode(&mut buf).expect("serialize key exchange");
        assert_eq!(
            buf.len(),
            kex.encoded_len()
                .expect("serialized length should match the buffer length")
        );
        assert_eq!(
            KeyExchangeInit::decode(&mut buf.as_slice()).expect("parse back the key exchange"),
            kex
        );
    }
}
