use encoding::{self, Decode, Encode, Error as EncodingError, Reader, Writer};
use rand_core::CryptoRngCore;

use super::Error;

/// [`Cookie`] is a random value generated by the sender.
///
/// See <https://www.rfc-editor.org/rfc/rfc4253#section-7.1>
#[derive(Clone, Debug, PartialEq)]
pub struct Cookie(pub [u8; Self::COOKIE_SIZE]);

impl Cookie {
    /// Size of the Cookie
    pub const COOKIE_SIZE: usize = 16;

    /// Creates a new [`Cookie`] from an rng.
    pub fn new<Rng>(rng: &mut Rng) -> Self
    where
        Rng: CryptoRngCore,
    {
        let mut out = [0; Self::COOKIE_SIZE];
        rng.fill_bytes(&mut out);
        Self(out)
    }
}

impl Decode for Cookie {
    type Error = Error;

    fn decode(reader: &mut impl Reader) -> Result<Self, Self::Error> {
        let mut out = [0; Self::COOKIE_SIZE];
        reader.read(&mut out[..])?;
        Ok(Self(out))
    }
}

impl Encode for Cookie {
    #[inline]
    fn encoded_len(&self) -> Result<usize, EncodingError> {
        Ok(Self::COOKIE_SIZE)
    }

    fn encode(&self, writer: &mut impl Writer) -> Result<(), EncodingError> {
        writer.write(&self.0)
    }
}

impl From<[u8; Cookie::COOKIE_SIZE]> for Cookie {
    fn from(inner: [u8; Self::COOKIE_SIZE]) -> Self {
        Self(inner)
    }
}
